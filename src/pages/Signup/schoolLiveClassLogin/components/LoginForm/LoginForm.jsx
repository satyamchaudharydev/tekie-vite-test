import React, { useEffect, useState } from "react";
import gql from "graphql-tag";
import qs from "query-string";
import "./LoginForm.scss";
import cx from "classnames";
import OTP from "react-otp-input";
import { Input } from "../../../../../photon";
import LoginWithPassword from "../LoginWithPassword/LoginWithPassword";
import {
  fetchComponentDetails,
  loginChangeType,
  moveToSession,
  renderHeader,
  verifyOTPHandler,
} from "../../utils";
import { MOBILE_BREAKPOINT } from "../../../../../config";
import { useHistory, useLocation } from "react-router";
import { connect } from "react-redux";
import { filterKey } from "duck-state/lib/State";
import {
  INCORRECT_OTP,
  INCORRECT_ROLL,
  NUM_LOCK_ON,
} from "../../constants/constants";
import { get } from "lodash";
import store from "../../../../../store";
import { fromJS } from "immutable";
import LoadingSpinner from "../../../../TeacherApp/components/Loader/LoadingSpinner";
import requestToGraphql from "../../../../../utils/requestToGraphql";
import SingleStudent from "../SingleStudent/SingleStudent";
import { avatarsRelativePath } from "../../../../../utils/constants/studentProfileAvatars";
import "../../assets/fonts/Gilroy.css";
import StudentList from "../StudentList";
import OtpForm from "./OtpForm";
import RollNosForm from "./RollNosForm";
import { LeftArrow } from "../../../../../constants/icons";
import extractSubdomain from "../../../../../utils/extractSubdomain";
import TekieButton from "../../../../../components/Buttons/TekieButton/TekieButton";
import getSystemId from "../../../../../utils/getOrGenerateSystemId";
import ErrorMessage from "../ErrorMessage/ErrorMessage";
import { useRef } from "react";
import {
  environments,
  HOSTNAME,
  LOCALHOST,
  STUDENT_APP_PREFIX,
} from "../../../../../constants";
import { setDataInLocalStorage } from "../../../../../utils/data-utils";
import classes from "./LoginForm.module.scss";
import { createMagicLink, createMagicLinkForBuddies } from "../../../../../utils/createMagicLink";
import redirectAccordingToSubdomainAndEnvironment from "../../../../../utils/redirectAccToSubdomainAndEnv";
import { gtmEvents } from "../../../../../utils/analytics/gtmEvents";
import { fireGtmEvent, userParamsMapper } from "../../../../../utils/analytics/gtmActions";
import { userParamsVariables } from "../../../../../utils/analytics/gtmConstants";
import { hs } from "../../../../../utils/size";

const LoginForm = ({
  setIsBuddLoginEnabled,
  setBuddyLoginLimit,
  step,
  setStep,
  width,
  loginWithEmail,
  setLoginWithEmail,
  schoolCode = "vss",
  batchDetails,
  setBatchDetails,
  loading,
  setIsLoading,
  buddyTeamList = [],
  setBuddyTeamList,
  buddyLimit,
  isBuddyLoginEnabled,
  isStudentSelected,
  setIsStudentSelected,
  selectedStudentDetails,
  setSelectedStudentDetails,
  setSchoolLogo,
  isRollNoAutoGenerated,
  setIsRollNoAutoGenerated,
  fromCentralizedLogin,
  ...props
}) => {
  const [input, setInput] = useState({
    code: "",
    value: "",
    type: "rollNo",
  });
  const [prevOtp, setPrevOtp] = useState("");
  const otpRef = useRef(null);
  const history = useHistory();
  const location = useLocation();
  const [error, setError] = useState(false);
  const [submitCredentials, setSubmitCredentials] = useState(false);
  const [queryFlag, setQueryFlag] = useState(false);
  const [batchStudents, setBatchStudents] = useState([]);
  const [selectedUserId, setSelectedUserId] = useState("");
  const [buttonDisabled, setButtonDisabled] = useState(false);
  const [password, setPassword] = useState("");
  const [errors, setErrors] = useState({
    email: "",
    password: "",
  });
  // const [isStudentSelected, setIsStudentSelected] = useState(false)
  // const [selectedStudentDetails, setSelectedStudentDetails] = useState(null)
  const [isAlreadyPresentInSystem, setIsAlreadyPresentInSystem] = useState(
    false
  );
  const [fetchingData, setFetchingData] = useState(false);
  const [isAutoSubmitted, setIsAutoSubmitted] = useState(false);
  const [numLock, setNumLock] = useState(false);
  const [isAddingStudent, setIsAddingStudent] = useState(false);
  const [studentsBuddyTeamList, setStudentsBuddyTeamList] = useState([]);
  const [buddyListCursor, setBuddyListCursor] = useState(0);

  let mobileView = width < MOBILE_BREAKPOINT;

  const moveToSessionHandler = async () => {

    const ebookID = get(qs.parse(location.search), 'ebookId')


    if (isAutoSubmitted) {
      setIsAutoSubmitted((prevVal) => !prevVal);
      return true;
    }
    let redirectStatus = await moveToSession(
      props.user.toJS(),
      true,
      history,
      loginWithEmail ? "" : input.code,
      setIsLoading,
      !loginWithEmail,
      {
        isBuddyLoginEnabled: props.isBuddyLoginEnabled,
        sessionId: get(batchDetails, "sessionId"),
        topicId: get(batchDetails, "topicId"),
        courseId: get(batchDetails, "courseId"),
        startTime: new Date(),
        isAutoSubmitted,
      },
      setIsAutoSubmitted
    );
    if (redirectStatus === false) {
      setIsLoading(false);
      setQueryFlag(false);
      store.dispatch({
        type: "user/delete/success",
        payload: fromJS({
          extractedData: {},
        }),
        autoReducer: true,
      });
      localStorage.clear();
    }
  };
  const prevBuddyTeamList = useRef([]);
  // useEffect(() => {
  //   if (buddyTeamList.length !== get(prevBuddyTeamList, "current", []).length) {
  //     if (
  //       buddyTeamList.length === 1 &&
  //       get(prevBuddyTeamList, "current", []).length < 1
  //     ) {
  //       setIsAutoSubmitted((prevVal) => !prevVal);
  //       continueButtonHandler("buddyLogin", true);
  //     } else if (buddyTeamList.length === 0) {
  //       setIsAutoSubmitted((prevVal) => !prevVal);
  //       props.dispatch({ type: "LOGOUT" });
  //     }
  //   }
  //   prevBuddyTeamList.current = buddyTeamList;
  // }, [buddyTeamList.length]);

  useEffect(() => {
    if (props.error) {
      const errors = props.error.toJS();
      const errorItem = errors[errors.length - 1];
      if (get(errorItem, "error.errors[0].message", "")) {
        if (
          get(errorItem, "error.errors[0].message", "").includes("email") ||
          get(errorItem, "error.errors[0].message", "").includes(
            "record not found"
          )
        ) {
          setErrors({
            ...errors,
            email: "Incorrect Email",
            password: "",
          });
        } else {
          setErrors({
            ...errors,
            email: "",
            password: "Incorrect Password",
          });
        }
      }

      setIsLoading(false);
      setSubmitCredentials(false);
    }
  }, [props.error]);

  useEffect(() => {
    if (error) setError(false);
  }, [input]);

  useEffect(() => {
    if (!loginWithEmail) return;
    if (!Object.keys(batchDetails).length) return;
    setBatchDetails({});
  }, [loginWithEmail]);

  useEffect(() => {
    if (props.user) {
      if (!queryFlag) moveToSessionHandler();
      setQueryFlag(true);
    }
  }, [props.user]);

  // useEffect(()=>{
  //   if(input.code && prevOtp &&  input.code.length < prevOtp.length) console.log(otpRef.current)
  //   //   otpRef.current.focusInput(input.code.length)
  // },[input.code])

  useEffect(() => {
    if (
      prevOtp !== get(input, "code") &&
      get(input, "code", "").length === 4 &&
      !loginWithEmail &&
      step === 0
    ) {
      continueButtonHandler();
    }
  }, [input.code]);

  useEffect(() => {
    const numPadKeys = [
      "Numpad0",
      "Numpad1",
      "Numpad2",
      "Numpad3",
      "Numpad4",
      "Numpad5",
      "Numpad6",
      "Numpad7",
      "Numpad8",
      "Numpad9",
    ];
    const handleKeyUp = (event) => {
      if (step > 0) return;
      const keyValue = numPadKeys.filter((key) => {
        return key === event.code;
      });
      if (keyValue && keyValue.length > 0) {
        if (event.getModifierState("NumLock")) {
          setError(false);
          setNumLock(false);
        } else {
          setNumLock(true);
          setError({ status: true, message: NUM_LOCK_ON });
        }
      }
    };
    if (typeof window === "undefined") return;
    window.addEventListener("keyup", handleKeyUp);
    return () => window.removeEventListener("keyup", handleKeyUp);
  }, []);

  useEffect(() => {
    setBuddyListCursor(0);
  }, [studentsBuddyTeamList]);

  const handleChange = (e) => {
    const alphaNumericCode = e.replace(/[^a-zA-Z0-9]/g, "");
    const upperCaseOtp = alphaNumericCode.toUpperCase();
    setPrevOtp(input.code);
    setInput({ ...input, code: upperCaseOtp });
    otpRef.current.focusInput(upperCaseOtp.length);
  };
  const verifySchoolOtp = async (schoolOtp) => {
    const schoolCode = extractSubdomain();
    try {
      const res = await requestToGraphql(`{
            getBatchDetails(otp:"${schoolOtp}" 
      ){
              batchId
              batchCode
              topicTitle
              topicId
              courseId
              classroomTitle
              sessionStartDate
              sessionStartTime
              startTime
              endTime
              sessionId
              schoolDetail{
                id
                isBuddyLoginEnabled
                buddyLoginLimit
                logo{
                    id
                    uri
                }
                isRollNoAutoGenerated
              }
              batchStudents{
                userId
                name
                grade
                section
                profileAvatar
                rollNo
              }
            }
          }`);
      const batchDetails = get(res, "data.getBatchDetails");
      setIsBuddLoginEnabled(
        get(batchDetails, "schoolDetail.isBuddyLoginEnabled")
      );
      setBuddyLoginLimit(get(batchDetails, "schoolDetail.buddyLoginLimit"));
      setIsRollNoAutoGenerated(
        get(batchDetails, "schoolDetail.isRollNoAutoGenerated")
      );
      //   setSchoolLogo(get(batchDetails, 'schoolDetail.logo.uri'))
      setDataInLocalStorage("currentSessionId", get(batchDetails, "sessionId"));
      setDataInLocalStorage("activeClassroom", get(batchDetails, "batchId"));
      return res;
    } catch (error) {
      return error;
    }
  };

  const redirectStudent = (token, { topicId, courseId, sessionId, ebookID }) => {
    // extract subdomain and check if we're on production
    const subdomain = extractSubdomain();

    // we don't need to redirect in this case
    if (subdomain === STUDENT_APP_PREFIX) return;

    // extract hostname, port and protocol from window.location
    const { protocol, hostname, port } = window.location;
    // if hostname is localhost, then redirect to student://...
    const isLocalhost = hostname === LOCALHOST;
    const isProduction = import.meta.env.REACT_APP_NODE_ENV === "production";
    if (isLocalhost) {
      let redirectURL = `${protocol}//${STUDENT_APP_PREFIX}:${port}?authToken=${token}&topicId=${topicId}&courseId=${courseId}&sessionId=${sessionId}`;
      if (ebookID && ebookID !== 'undefined') {
        redirectURL = `${redirectURL}&ebookId=${ebookID}`
      }
      window.location.href = redirectURL;
    }
    if (isProduction) {
      let redirectURL = `${protocol}//${STUDENT_APP_PREFIX}.${HOSTNAME}?authToken=${token}&topicId=${topicId}&courseId=${courseId}&sessionId=${sessionId}`;
      if (ebookID && ebookID !== 'undefined') {
        redirectURL = `${redirectURL}&ebookId=${ebookID}`
      }
    }
    else {
      let redirectURL = `${protocol}//${STUDENT_APP_PREFIX}-${environments[import.meta.env.REACT_APP_NODE_ENV]
        }.${HOSTNAME}?authToken=${token}&topicId=${topicId}&courseId=${courseId}&sessionId=${sessionId}`;
      if (ebookID && ebookID !== 'undefined') {
        redirectURL = `${redirectURL}&ebookId=${ebookID}`
      }
      window.location.href = redirectURL;
    }
  };

  const continueButtonHandler = async (
    type = "singleLogin",
    isAutoSubmitting = false
  ) => {
    try {
      const userFetchStatus = get(props, "userFetchStatus", false);
      if (loginWithEmail) {
        setSubmitCredentials(true);
        return;
      }

      if (buddyTeamList.length > 1) {
        setIsAutoSubmitted(false);
      }

      let shouldReplaceCurrentUser = false;
      if (buddyTeamList.length === 1) {
        const userData = props.user && props.user.toJS();
        if (
          get(userData, "id") &&
          get(buddyTeamList, "[0].userId") !== get(userData, "id")
        ) {
          shouldReplaceCurrentUser = true;
        }
      }

      if (userFetchStatus) return true;

      if (type === "buddyLogin" && buddyTeamList.length > 0) {
        const buddyLoginInput = [];
        buddyTeamList.forEach((buddy, ind) => {
          let isPrimaryUser = false;
          if (ind === 0) {
            isPrimaryUser = true;
          }
          buddyLoginInput.push({ userId: get(buddy, "userId"), isPrimaryUser });
        });
        if (!isAutoSubmitting) setIsLoading(true);
        const user = props.user && props.user.toJS();
        if (
          (get(user, "id") && buddyTeamList.length > 1) ||
          shouldReplaceCurrentUser
        ) {
          if (shouldReplaceCurrentUser) props.dispatch({ type: "LOGOUT" });
          await verifyOTPHandler("", buddyLoginInput, setIsLoading);
        }
        if (!get(user, "id")) {
          const response = await verifyOTPHandler(
            "",
            buddyLoginInput,
            setIsLoading
          );

          if (get(response, 'schoolLiveClassLoginViaOtp', null)) {
            const { schoolLiveClassLoginViaOtp } = response
            const { role, id, studentProfile } = schoolLiveClassLoginViaOtp

            const userParams = {
              userId: id,
              role,
              schoolId: get(studentProfile, "school.id"),
              schoolName: get(studentProfile, "school.name"),
              grade: get(studentProfile, "grade"),
              rollNo: get(studentProfile, "rollNo"),
              section: get(studentProfile, "section"),
              userName: get(studentProfile, "user.name"),
              coursePackageName: get(studentProfile, 'batch.coursePackage.title'),
              batchId: get(studentProfile, 'batch.id'),
              classroomTitle: get(studentProfile, 'batch.classroomTitle'),
            }
            fireGtmEvent(
              gtmEvents.otpLoginSuccess, { userParams }
            )
          }
          // if (buddyTeamList.length === 1) {
          //   await fetchComponentDetails({
          //     user,
          //     code: get(input, "code"),
          //     topicId: get(batchDetails, "topicId"),
          //     courseId: get(batchDetails, "courseId"),
          //     sessionId: get(batchDetails, "sessionId"),
          //   });
          // }
        } else moveToSessionHandler();
        return;
      }

      if (loginWithEmail) {
        setSubmitCredentials(true);
        return;
      }

      if (step === 0) {
        setIsLoading(true);
        let otpVerificationStatus = await verifySchoolOtp(input.code);
        setIsLoading(false);
        if (get(otpVerificationStatus, "errors", []).length) {
          // gtm - unsuccessful otp verification
          const failedOtpValidationEvent = gtmEvents.otpValidationFailed
          fireGtmEvent(failedOtpValidationEvent)
          setError({ status: true, message: INCORRECT_OTP });
        } else {
          const successfulOtpValidationEvent = gtmEvents.otpValidationSuccess
          fireGtmEvent(successfulOtpValidationEvent)
          setStep((prevStep) => prevStep + 1);
          setBatchDetails(get(otpVerificationStatus, "data.getBatchDetails"));
        }
      } else {
        if (step === 1) {
          setIsLoading(true);
          setFetchingData(true);
          let batchStudentData = get(batchDetails, "batchStudents", []).find(
            (student) => get(student, "rollNo") === get(input, "value")
          );

          if (!batchStudentData) {
            setIsLoading(false);
            setFetchingData(false);
            return setError({ status: true, message: INCORRECT_ROLL });
          }
          await verifyOTPHandler(
            get(batchStudentData, "userId"),
            [],
            setIsLoading
          );

        } else if (step === 2) {
          setIsLoading(true);
          await verifyOTPHandler(selectedUserId, [], setIsLoading);


        }
      }
    } catch (err) {
      setFetchingData(false);
    }
  };

  const checkIfFieldsEmpty = (email, password) => {
    setButtonDisabled(!(email.length && password.length));
  };

  const verifyPassword = async () => {
    try {
      setFetchingData(true);
      const res = await requestToGraphql(`{
                getBuddyStatus(sessionId:"${get(
        batchDetails,
        "sessionId"
      )}", userId:"${get(
        selectedStudentDetails,
        "userId"
      )}", systemId:"${getSystemId()}", password:"${password}",action:"confirmPassword"){
                  error
                  result
                }
              }`);
      if (get(res, "data.getBuddyStatus.result")) {
        //first we delete and then add
        await requestToGraphql(`{
                    getBuddyStatus(sessionId:"${get(
          batchDetails,
          "sessionId"
        )}", userId:"${get(
          selectedStudentDetails,
          "userId"
        )}", systemId:"${getSystemId()}",action:"delete"){
                      error
                      result
                    }
                  }`);
        await requestToGraphql(`{
                    getBuddyStatus(sessionId:"${get(
          batchDetails,
          "sessionId"
        )}", userId:"${get(
          selectedStudentDetails,
          "userId"
        )}", systemId:"${getSystemId()}",action:"add"){
                      error
                      result
                    }
                  }`);
        setFetchingData(false);
        setIsAlreadyPresentInSystem(false);
        setIsStudentSelected(true);
        setErrors((prev) => ({ ...prev, password: "" }));
        setBuddyTeamList((prev) => [
          ...prev,
          {
            avatar: get(selectedStudentDetails, "avatar"),
            name: get(selectedStudentDetails, "name"),
            rollNo: get(selectedStudentDetails, "rollNo"),
            userId: get(selectedStudentDetails, "userId"),
          },
        ]);
        renderOtpOrRollnoInput(1);
      } else {
        setFetchingData(false);
      }
    } catch (err) {
      setFetchingData(false);
      setError(true);
      setErrors((prev) => ({
        ...prev,
        password: get(err, "errors[0].message"),
      }));
    }
  };

  const goBackHandler = () => {
    setStep(1);
    setIsStudentSelected(true);
    setSelectedStudentDetails({
      avatar: get(buddyTeamList[buddyTeamList.length - 1], "avatar"),
      name: get(buddyTeamList[buddyTeamList.length - 1], "name"),
      rollNo: get(buddyTeamList[buddyTeamList.length - 1], "rollNo"),
      userId: get(buddyTeamList[buddyTeamList.length - 1], "userId"),
    });
  };

  const reEnterClassCodeHandler = () => {
    setStep(0);
    setBuddyTeamList([]);
    setBatchDetails({});
  };

  const addToTeam = async ({ avatar, name, rollNo, userId }) => {
    const sessionId = get(batchDetails, "sessionId");
    try {
      setFetchingData(true);
      setIsAddingStudent(true);
      const res = await requestToGraphql(`{
                getBuddyStatus(sessionId:"${sessionId}", userId:"${userId}", systemId:"${getSystemId()}", action:"add"){
                  error
                  result
                }
              }`);
      if (get(res, "data.getBuddyStatus.result")) {
        // buddy added event
        fireGtmEvent(gtmEvents.addBuddySuccess)
        setBuddyTeamList((prev) => [...prev, { avatar, name, rollNo, userId }]);
        setFetchingData(false);
        setIsAddingStudent(false);
        setIsStudentSelected(true);
        setInput({});
        setSelectedStudentDetails({ avatar, name, rollNo, userId });
      }
    } catch (error) {
      setFetchingData(false);
      setIsAddingStudent(false);
      return error;
    }
  };

  const renderOtpOrRollnoInput = (step) => {
    if (loginWithEmail)
      return (
        <form
          onSubmit={(e) => {
            e.preventDefault();
            if (!loading) continueButtonHandler();
          }}
        >
          <LoginWithPassword
            submitCredentials={submitCredentials}
            setSubmitCredentials={setSubmitCredentials}
            setIsLoading={setIsLoading}
            loading={loading}
            loginWithEmail={loginWithEmail}
            checkIfFieldsEmpty={checkIfFieldsEmpty}
            errors={errors}
            setErrors={setErrors}
          />
          <button type="submit" style={{ display: "none" }} />
        </form>
      );
    switch (step) {
      case 0:
        return (
          <form
            onSubmit={(e) => {
              e.preventDefault();
              if (input.code.length === 4 && !loading) continueButtonHandler();
            }}
          >
            <OTP
              ref={otpRef}
              shouldAutoFocus
              value={input.code}
              onChange={handleChange}
              className={"school-live-class-login-photonOtpContainer"}
              inputStyle={cx(
                "school-live-class-login-photonInput",
                "school-live-class-login-photonOtpInput",
                error && !numLock && "school-live-class-login-error",
                "school-live-class-login-photonInputOtp"
              )}
            />
            <button type="submit" style={{ display: "none" }} />
          </form>
        );
      case 1:
        if (isAlreadyPresentInSystem) {
          return (
            <div>
              <div
                className={"school-live-class-login-selectedStudentContainer"}
              >
                <div
                  className={"school-live-class-login-avatarAndNameContainer"}
                >
                  <img
                    className={"school-live-class-login-avatar"}
                    src={
                      avatarsRelativePath[get(selectedStudentDetails, "avatar")]
                    }
                    alt="student-avatar"
                  />
                  <div
                    className={"school-live-class-login-rollNoAndNameContainer"}
                  >
                    {!isRollNoAutoGenerated && (
                      <span>{get(selectedStudentDetails, "rollNo")} - </span>
                    )}
                    <span className={"school-live-class-login-studentName"}>
                      {get(selectedStudentDetails, "name")}
                    </span>
                  </div>
                </div>
              </div>
              <Input
                value={password}
                autoComplete="off"
                type="password"
                placeholder="Enter Password"
                parentClassName={["school-live-class-login-parentInputField"]}
                className={cx(
                  "school-live-class-login-inputField",
                  error && "error",
                  width < 900 && "school-live-class-login-mobileRollNumberField"
                )}
                onChangeText={(e) => {
                  setPassword(e.trim());
                  setError(false);
                }}
              />
              <ErrorMessage
                message={get(errors, "password")}
                withCrossIcon={true}
              />
              <div style={{ marginTop: "8px" }}>
                <TekieButton
                  isLoading={fetchingData || loading}
                  isDisabled={!password ? true : false}
                  onBtnClick={() => verifyPassword()}
                  text="Continue"
                  widthFull
                />
              </div>

              {!isStudentSelected && (
                <p
                  role={"button"}
                  onClick={() => {
                    setIsAlreadyPresentInSystem(false);
                    setSelectedStudentDetails({});
                    setPassword("");
                    setError(false);
                  }}
                  className={"school-live-class-login-reEnterCode"}
                >
                  <LeftArrow /> Go back
                </p>
              )}
            </div>
          );
        }
        if (isStudentSelected) {
          return (
            <div
              className={"school-live-class-login-inputAndStudentListContainer"}
            >
              <div
                className={"school-live-class-login-selectedStudentContainer"}
              >
                <div
                  className={"school-live-class-login-avatarAndNameContainer"}
                >
                  <img
                    className={"school-live-class-login-avatar"}
                    src={
                      avatarsRelativePath[get(selectedStudentDetails, "avatar")]
                    }
                    alt="student-avatar"
                  />
                  <div
                    className={"school-live-class-login-rollNoAndNameContainer"}
                  >
                    <p className={"school-live-class-login-studentName"}>
                      {!isRollNoAutoGenerated
                        ? `${get(selectedStudentDetails, "rollNo")} - `
                        : ""}{" "}
                      {get(selectedStudentDetails, "name")}
                    </p>
                  </div>
                </div>
                <div className={"school-live-class-login-checkmarkContainer"}>
                  <AnimatedCheckMark />
                </div>
              </div>
            </div>
          );
        }
        return (
          <>
            {" "}
            <div
              className={"school-live-class-login-inputAndStudentListContainer"}
            >
              <Input
                value={input.value}
                autoComplete="off"
                autoFocus
                parentClassName={["school-live-class-login-parentInputField"]}
                className={cx(
                  "school-live-class-login-inputField",
                  error && "error",
                  width < 900 && "school-live-class-login-mobileRollNumberField"
                )}
                onChangeText={(e) => {
                  let alphaNumericText = /^[a-z0-9]+$/i;
                  let isRollNosInput = /[0-9]+/i;
                  if (e.length && !alphaNumericText.test(e)) return;
                  if (e.length && isRollNosInput.test(e)) {
                    setInput({
                      ...input,
                      value: e.trim(),
                      type: "rollNo",
                    });
                  } else {
                    setInput({
                      ...input,
                      value: e.trim(),
                      type: "name",
                    });
                  }
                }}
                onKeyDown={(e) => {
                  if (e.keyCode === 38 && buddyListCursor > 0) {
                    setBuddyListCursor(buddyListCursor - 1);
                  } else if (
                    e.keyCode === 40 &&
                    buddyListCursor < studentsBuddyTeamList.length - 1
                  ) {
                    setBuddyListCursor(buddyListCursor + 1);
                  } else if (
                    e.keyCode === 13 &&
                    studentsBuddyTeamList.length > 0
                  ) {
                    const student = studentsBuddyTeamList[buddyListCursor];
                    const avatar = get(student, "profileAvatar");
                    const name = get(student, "name");
                    const rollNo = get(student, "rollNo");
                    const userId = get(student, "userId");
                    addToTeam({ avatar, name, rollNo, userId });
                  }
                }}
              />
              {error && (
                <p className={"school-live-class-login-errorText"}>
                  Incorrect roll number
                </p>
              )}
              {get(input, "value") && (
                <div className={"school-live-class-login-studentListContainer"}>
                  <StudentList
                    setIsStudentSelected={setIsStudentSelected}
                    setSelectedStudentDetails={setSelectedStudentDetails}
                    rollNoOrName={get(input, "value")}
                    typeOfInput={get(input, "type")}
                    setInput={setInput}
                    students={get(batchDetails, "batchStudents")}
                    buddyTeamList={buddyTeamList}
                    setBuddyTeamList={setBuddyTeamList}
                    isAlreadyPresentInSystem={isAlreadyPresentInSystem}
                    setIsAlreadyPresentInSystem={setIsAlreadyPresentInSystem}
                    setPassword={setPassword}
                    fetchingData={fetchingData}
                    setFetchingData={setFetchingData}
                    isRollNoAutoGenerated={isRollNoAutoGenerated}
                    input={get(input, "value")}
                    studentsBuddyTeamList={studentsBuddyTeamList}
                    setStudentsBuddyTeamList={setStudentsBuddyTeamList}
                    buddyListCursor={buddyListCursor}
                    addToTeam={addToTeam}
                    isAddingStuden={isAddingStudent}
                  />
                </div>
              )}
              {!isBuddyLoginEnabled && (
                <TekieButton
                  onBtnClick={continueButtonHandler}
                  text="Continue"
                  widthFull
                  isLoading={fetchingData || loading}
                />
              )}
            </div>
            <p
              role={"button"}
              onClick={
                buddyTeamList.length ? goBackHandler : reEnterClassCodeHandler
              }
              className={"school-live-class-login-reEnterCode"}
            >
              <LeftArrow color={"#a8a7a7"} />
              {buddyTeamList.length === 0 ? "Re-enter OTP" : "Go Back"}
            </p>
          </>
        );
      case 2:
        if (!batchStudents.length) return;
        return (
          <div className={"school-live-class-login-studentsContainer"}>
            {batchStudents.map((singleStudentData) => {
              return (
                <SingleStudent
                  userId={singleStudentData.userId}
                  avatar={avatarsRelativePath[singleStudentData.profileAvatar]}
                  grade={singleStudentData.grade}
                  section={singleStudentData.section}
                  name={singleStudentData.name}
                  selectedUserId={selectedUserId}
                  setSelectedUserId={setSelectedUserId}
                  setStep={setStep}
                />
              );
            })}
          </div>
        );
      default:
        return;
    }
  };

  const changeLoginMethod = () => {
    if (step) setStep(0);
    setSubmitCredentials(false);
    setError("");
    setLoginWithEmail(!loginWithEmail);
    if (!loginWithEmail) {
      fireGtmEvent(gtmEvents.emailLoginBtnClick)
    }
  };

  const renderButtonContent = () => {
    if (loading) {
      return (
        <div className={"school-live-class-login-loaderContainer"}>
          <LoadingSpinner
            showLoader
            height={"100%"}
            width={"100%"}
            color="white"
          />
        </div>
      );
    }
    if (mobileView && step) return "Enter Class";
    return "Continue";
  };

  const checkIfButtonDisabled = () => {
    if (loginWithEmail) return loading || buttonDisabled;
    return (
      loading ||
      (!step && get(input, "code", "").length !== 4) ||
      (step === 1 && !input.value.trim().length) ||
      (step === 2 && !selectedUserId)
    );
  };

  const renderFormContent = (step) => {
    switch (step) {
      case 0:
        return (
          <OtpForm
            renderOtpOrRollnoInput={renderOtpOrRollnoInput}
            loginWithEmail={loginWithEmail}
            step={step}
            error={error}
            width={width}
            continueButtonHandler={continueButtonHandler}
            checkIfButtonDisabled={checkIfButtonDisabled}
            renderButtonContent={renderButtonContent}
            changeLoginMethod={changeLoginMethod}
            loginChangeType={loginChangeType}
            numLock={numLock}
          />
        );
      case 1:
        return (
          <RollNosForm
            isBuddyLoginEnabled={isBuddyLoginEnabled}
            isStudentSelected={isStudentSelected}
            setIsStudentSelected={setIsStudentSelected}
            renderOtpOrRollnoInput={renderOtpOrRollnoInput}
            buddyLimit={buddyLimit}
            totalBuddiesAdded={buddyTeamList.length}
            continueButtonHandler={continueButtonHandler}
            fetchingData={fetchingData}
            loading={loading}
            setStep={setStep}
          />
        );
      default: {
        throw new Error("Unhandled login step!");
      }
    }
  };
  return (
    <>
      <div className={"school-live-class-login-formContainer"}>
        {isStudentSelected && (
          <>
            <div
              className={classes.backButton}
              onClick={() => {
                setIsStudentSelected(false);
              }}
            >
              <LeftArrow width={hs(18)} height={hs(28)} color='#858585' />
              Go Back
            </div>
          </>
        )}

        <p className={classes.headerText}>Student Login</p>

        <p className={"school-live-class-login-joinClassText"}>
          {renderHeader(
            loginWithEmail,
            step,
            isStudentSelected,
            isAlreadyPresentInSystem,
            buddyTeamList.length,
            isRollNoAutoGenerated
          )}
        </p>
        <div className={"school-live-class-login-formContent"}>
          {renderFormContent(step)}
        </div>
      </div>
    </>
  );
};

const mapStateToProps = (state) => ({
  user: filterKey(state.data.getIn(["user", "data"]), "loggedinUser").get(0),
  userFetchStatus: state.data.getIn([
    "user",
    "fetchStatus",
    "loggedinUser",
    "loading",
  ]),
  error: state.data.getIn(["errors", "user/fetch"]),
});

export default connect(mapStateToProps)(LoginForm);

export const AnimatedCheckMark = () => {
  return (
    <div className={"school-live-class-login-wrapper"}>
      <div className={"school-live-class-login-wrapper"}>
        {" "}
        <svg
          className={"school-live-class-login-checkmark"}
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 52 52"
        >
          {" "}
          <circle
            className={"school-live-class-login-checkmark__circle"}
            cx="26"
            cy="26"
            r="25"
            fill="none"
          />{" "}
          <path
            className={"school-live-class-login-checkmark__check"}
            stroke-linejoin="round"
            stroke-linecap="round"
            fill="none"
            d="M14.1 27.2l7.1 7.2 16.7-16.8"
          />
        </svg>
      </div>
    </div>
  );
};
